<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Tetris Solo</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="bg-white flex justify-center items-center min-h-screen">
  <div class="flex gap-6">
    <canvas id="game-board" class="bg-black"></canvas>
    <div class="flex flex-col justify-start text-green-500 text-2xl space-y-4">
      <div><strong>이름</strong></div>
      <div id="score">점수: 0</div>
      <div id="time">남은 시간: 0sec</div>
      <button id="play-btn" class="bg-green-500 text-white px-4 py-2 rounded-md">Play</button>
    </div>
  </div>

  <script>
    const COLS = 10;
    const ROWS = 15;
    const BLOCK_SIZE = window.innerHeight * 0.06;

    const KEY = { LEFT: 37, RIGHT: 39, DOWN: 40, UP: 38, SPACE: 32 };
    Object.freeze(KEY);

    const MOVES = {
      [KEY.LEFT]: { dx: -1, dy: 0 },
      [KEY.RIGHT]: { dx: 1, dy: 0 },
      [KEY.DOWN]: { dx: 0, dy: 1 }
    };

    const SHAPES = [
      { name: 'I', color: 'cyan', blocks: [[0,0],[1,0],[2,0],[3,0]], center: [1,0] },
      { name: 'J', color: 'blue', blocks: [[0,0],[0,1],[1,1],[2,1]], center: [1,1] },
      { name: 'L', color: 'orange', blocks: [[2,0],[0,1],[1,1],[2,1]], center: [1,1] },
      { name: 'O', color: 'yellow', blocks: [[0,0],[1,0],[0,1],[1,1]], center: null },
      { name: 'S', color: 'green', blocks: [[1,0],[2,0],[0,1],[1,1]], center: [1,1] },
      { name: 'T', color: 'purple', blocks: [[1,0],[0,1],[1,1],[2,1]], center: [1,1] },
      { name: 'Z', color: 'red', blocks: [[0,0],[1,0],[1,1],[2,1]], center: [1,1] }
    ];

    const gameState = {
      canvas: document.getElementById('game-board'),
      ctx: null,
      grid: [],
      currentBlock: null
    };

    function setupCanvas() {
      const canvas = gameState.canvas;
      canvas.width = COLS * BLOCK_SIZE;
      canvas.height = ROWS * BLOCK_SIZE;

      const ctx = canvas.getContext('2d');
      ctx.scale(BLOCK_SIZE, BLOCK_SIZE);
      gameState.ctx = ctx;
    }

    function createEmptyBoard() {
      return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function drawGrid() {
      const ctx = gameState.ctx;
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 0.05;

      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath(); ctx.moveTo(0, r); ctx.lineTo(COLS, r); ctx.stroke();
      }

      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath(); ctx.moveTo(c, 0); ctx.lineTo(c, ROWS); ctx.stroke();
      }
    }

    function drawBlock(block) {
      const ctx = gameState.ctx;
      ctx.fillStyle = block.color;
      block.blocks.forEach(([x, y]) => {
        ctx.fillRect(block.x + x, block.y + y, 1, 1);
      });
    }

    function render() {
      const ctx = gameState.ctx;
      ctx.clearRect(0, 0, COLS, ROWS);
      drawGrid();
      if (gameState.currentBlock) drawBlock(gameState.currentBlock);
    }

    function createBlock() {
      const index = Math.floor(Math.random() * SHAPES.length);
      const shape = SHAPES[index];
      return {
        ...shape,
        x: 3,
        y: 0,
        blocks: shape.blocks.map(p => [...p]) // 깊은 복사
      };
    }

    function isCollision(grid, block, x, y, nextBlocks = block.blocks) {
      return nextBlocks.some(([bx, by]) => {
        const nx = x + bx;
        const ny = y + by;
        return (
          nx < 0 || nx >= COLS || ny >= ROWS ||
          (ny >= 0 && grid[ny][nx] !== 0)
        );
      });
    }

    function moveBlock(dx, dy) {
      const block = gameState.currentBlock;
      const nx = block.x + dx;
      const ny = block.y + dy;
      if (!isCollision(gameState.grid, block, nx, ny)) {
        block.x = nx;
        block.y = ny;
        render();
      }
    }

    function rotateBlock() {
      const block = gameState.currentBlock;
      if (!block.center) return;
      const [cx, cy] = block.center;
      const rotated = block.blocks.map(([x, y]) => {
        const relX = x - cx;
        const relY = y - cy;
        const newX = -relY + cx;
        const newY = relX + cy;
        return [newX, newY];
      });
      if (!isCollision(gameState.grid, block, block.x, block.y, rotated)) {
        block.blocks = rotated;
        render();
      }
    }

    function hardDrop() {
      const block = gameState.currentBlock;
      while (!isCollision(gameState.grid, block, block.x, block.y + 1)) {
        block.y++;
      }
      render();
      fixBlockToGrid();
    }

    function fixBlockToGrid() {
      const { grid, currentBlock: block } = gameState;
      block.blocks.forEach(([x, y]) => {
        const gx = block.x + x;
        const gy = block.y + y;
        if (gy >= 0) grid[gy][gx] = 1;
      });
    }

    function handleKeyDown(e) {
      const move = MOVES[e.keyCode];
      if (move) {
        e.preventDefault();
        moveBlock(move.dx, move.dy);
      } else if (e.keyCode === KEY.UP) {
        e.preventDefault();
        rotateBlock();
      } else if (e.keyCode === KEY.SPACE) {
        e.preventDefault();
        hardDrop();
      }
    }

    function startGame() {
      gameState.grid = createEmptyBoard();
      gameState.currentBlock = createBlock();
      render();
    }

    setupCanvas();
    drawGrid();
    document.addEventListener('keydown', handleKeyDown);
    document.getElementById('play-btn').addEventListener('click', startGame);
  </script>
</body>
</html>