<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Tetris Solo</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="bg-white flex justify-center items-center min-h-screen">
  <div class="flex gap-6">
    <canvas id="game-board" class="bg-black"></canvas>
    <div class="flex flex-col justify-start text-green-500 text-2xl space-y-4">
      <div><strong>이름</strong></div>
      <div id="score">점수: 0</div>
      <div id="time">남은 시간: 0sec</div>
      <button id="play-btn" class="bg-green-500 text-white px-4 py-2 rounded-md">Play</button>
    </div>
  </div>

  <script>
    const COLS = 10;
    const ROWS = 15;
    const BLOCK_SIZE = window.innerHeight * 0.06; // 6vh

    const KEY = {
      LEFT: 37,
      RIGHT: 39,
      DOWN: 40,
      UP: 38,
      SPACE: 32
    };
    Object.freeze(KEY);

    const MOVES = {
      [KEY.LEFT]: { dx: -1, dy: 0 },
      [KEY.RIGHT]: { dx: 1, dy: 0 },
      [KEY.DOWN]: { dx: 0, dy: 1 }
    };

    const COLORS = [  
      'cyan',    // I
      'blue',    // J
      'orange',  // L
      'yellow',  // O
      'green',   // S
      'purple',  // T
      'red'      // Z
    ];

    const SHAPES = [
      // I
      [
        [1, 1, 1, 1], 
        [0, 0, 0, 0], 
        [0, 0, 0, 0], 
        [0, 0, 0, 0]
      ],
      // J
      [
        [2, 0, 0], 
        [2, 2, 2], 
        [0, 0, 0]
      ],
      // L
      [
        [0, 0, 3], 
        [3, 3, 3], 
        [0, 0, 0]
      ],
      // O
      [
        [4, 4], 
        [4, 4]
      ],
      // S
      [
        [0, 5, 5], 
        [5, 5, 0], 
        [0, 0, 0]
      ],
      // T
      [
        [0, 6, 0], 
        [6, 6, 6], 
        [0, 0, 0]
      ],
      // Z
      [
        [7, 7, 0], 
        [0, 7, 7], 
        [0, 0, 0]
      ]
    ];


    // 게임 상태 객체
    const gameState = {
      canvas: document.getElementById('game-board'),
      ctx: null,
      grid: [],
      currentBlock: null
    };

    function setupCanvas() {
      const canvas = gameState.canvas;
      canvas.width = COLS * BLOCK_SIZE;
      canvas.height = ROWS * BLOCK_SIZE;

      const ctx = canvas.getContext('2d');
      ctx.scale(BLOCK_SIZE, BLOCK_SIZE);
      gameState.ctx = ctx;
    }

    function createEmptyBoard() {
      return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function clearCanvas() {
      gameState.ctx.clearRect(0, 0, COLS, ROWS);
    }

    // 격자 그리기
    function drawGrid() {
      const ctx = gameState.ctx;
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 0.05;

      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r);
        ctx.lineTo(COLS, r);
        ctx.stroke();
      }

      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(c, 0);
        ctx.lineTo(c, ROWS);
        ctx.stroke();
      }
    }

    function drawBlock(block) {
      const ctx = gameState.ctx;
      ctx.fillStyle = block.color;
      block.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value > 0) {
            ctx.fillRect(block.x + x, block.y + y, 1, 1);
          }
        });
      });
    }

    function render() {
      clearCanvas();
      drawGrid();
      if (gameState.currentBlock) {
        drawBlock(gameState.currentBlock);
      }
    }

    function createBlock() {
      const index = Math.floor(Math.random() * SHAPES.length);
      return {
        x: 3,
        y: 0,
        color: COLORS[index],
        shape: SHAPES[index]
      };
    }

    function moveBlock(dx, dy) {

      const block = gameState.currentBlock;
      const newX = block.x + dx;
      const newY = block.y + dy;

      if (!isCollision(gameState.grid, block, newX, newY)) {
        block.x = newX;
        block.y = newY;
        render();
      }
    }

    function rotate(shape) {
      const N = shape.length;
      const result = Array.from({ length: N }, () => Array(N).fill(0));

      for (let y = 0; y < N; y++) {
        for (let x = 0; x < N; x++) {
          result[x][N - 1 - y] = shape[y][x];
        }
      }

      return result;
    }

    function rotateBlock() {
      const block = gameState.currentBlock;
      const rotatedShape = rotate(block.shape);

      if (!isCollision(gameState.grid, block, block.x, block.y, rotatedShape)) {
        block.shape = rotatedShape;
        render();
      }
    }

    function isCollision(grid, block, nextX, nextY, nextShape) {
      const shape = nextShape || block.shape;

      return !shape.every((row, y) => {
        return row.every((value, x) => {
          if (value === 0) return true;

          const newX = nextX + x;
          const newY = nextY + y;

          const insideBoard = newX >= 0 && newX < COLS && newY < ROWS;
          const notBlocked = newY < 0 || (grid[newY] && grid[newY][newX] === 0);
          return insideBoard && notBlocked;
        });
      });
    }

    function hardDrop() {
      const block = gameState.currentBlock;
      let dropY = block.y;

      // 아래로 계속 떨어뜨리면서 충돌 안 나는 지점 찾기
      while (!isCollision(gameState.grid, block, block.x, dropY + 1)) {
        dropY++;
      }

      // 최종 위치에 블럭 위치 고정
      block.y = dropY;
      render();

      // 블럭 고정 처리 (grid에 반영)
      fixBlockToGrid();
    }

    function fixBlockToGrid() {
      const { grid, currentBlock: block } = gameState;

      block.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value > 0) {
            const gx = block.x + x;
            const gy = block.y + y;

            if (gy >= 0) grid[gy][gx] = value;  // 격자에 블럭 고정
          }
        });
      });
    }

    function handleKeyDown(e) {
      const move = MOVES[e.keyCode];
      if (move) {
        e.preventDefault();
          moveBlock(move.dx, move.dy);
      } else if (e.keyCode === KEY.UP) {
        e.preventDefault();
        rotateBlock();
      } else if (e.keyCode === KEY.SPACE) {
        e.preventDefault();
        hardDrop();
      }
    }

    function startGame() {
      gameState.grid = createEmptyBoard();
      gameState.currentBlock = createBlock();
      render();
    }
    
    setupCanvas();
    drawGrid();
    document.addEventListener('keydown', handleKeyDown);
    document.getElementById('play-btn').addEventListener('click', startGame);
  </script>
</body>
</html>
